<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tanulóoldal</title>
  <link rel="stylesheet" href="bootstrap-5.2.0-beta1-dist/css/bootstrap.min.css">
  <link rel="stylesheet" href="index.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Roboto&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="css az aloldalaknak/javascript.css">
</head>

<body id="oldalteteje">
  <header>
    <h1 id="javaScript">javaScript (nightmare)
  </header>
  <main class="container-fluid">
    <div class="row no-gutters">
      <nav class="col-12 col-md-3 col-lg-2 navbar">
        <ul class="navmenu">
          <li><a href="index.html"><strong>Főoldal</strong></a></li>
          <li><a href="css.html"><strong>CSS</strong></a></li>
          <li><a href="github.html"><strong>GitHub</strong></a></li>
          <li><a href="javaScript.html"><strong>JavaScript (easy)</strong></a></li>
          <li><a href="javaScriptnormal.html"><strong>JavaScript (normal)</strong></a></li>
          <li><a href="javaScripthard.html"><strong>JavaScript (hard)</strong></a></li>
          <li><a href="javaScriptnightmare.html"><strong>JavaScript (nightmare)</strong></a></li>
        </ul>
      </nav>
      <div class="col-12 col-md-6 col-lg-8 tartalom">
        <h2 id="dom">A DOM</h2>
        <p>A JavaScript egyik fő célja a HTML dokumentumok dinamikus kezelése. Erre a célra a böngészőben az ún.
          Document Object Modelt (a továbbiakban DOM) tudod használni.</p>
        <p>A JavaScript egyik fő célja a HTML dokumentumok dinamikus kezelése. Erre a célra a böngészőben az ún.
          Document Object Model DOM API segítségével lekérdezheted és változtathatod a HTML elemeket. Az API-t a
          globális document objektumon keresztül éred el.</p>
        <p>Egy HTML elemhez többféleképpen is hozzáférhetsz.</p>
        <p><strong>document.getElementById</strong></p>
        <p>Az elemet az id attribútum alapján szeretném elérni. Mivel az id-nak egyedinek kell lennie egy oldalon, ezért
          ez a függvény az adott elemet adja vissza (egész pontosan egy objektumot ad vissza, amin keresztül tudod az
          elemet módosítani).</p>
        <p><strong>document.getElementsByName</strong></p>
        <p>Hasonló a getElementById függvényhez, de itt a name attribútum alapján történik a keresés. Figyeljük meg az
          apró különbséget, az elements a függvény nevében többesszámban van. Ez a függvény egy tömböt fog visszaadni
          nekünk.</p>
        <p><strong>docmument.getElementsByName('myDiv')</strong></p>
        <p>Természetesen név alapján lehet rámutatni az elementre.</p>
        <p><strong>document.getElementsByClassName</strong></p>
        <p>A class attribútum alapján visszakapjuk azokat a HTML elemeket egy tömbben.
        </p>
        <p><strong>document.getElementsByTagName</strong></p>
        <p>Ez a függvény minden elemet visszaad nekünk, aminek a típusa a megadott tag.
        </p>
        <p><strong>document.querySelector</strong></p>
        <p>Ez a függvény CSS selectorok alapján keres nekünk HTML elemeket, majd visszaadja az első találatot.</p>
        <p><strong>document.querySelectorAll</strong></p>
        <p>Szintén CSS selectorok alapján keres nekünk HTML elemeket, de minden egyező elemet visszaad nekünk.</p>
        <p><strong>Element - a DOM elemek őse</strong></p>
        <p>Az Element objektumon keresztül érjük el az oldalon található HTML elemeket. Mutatok pár érdekes dolgot vele
          kapcsolatban, és fel is okosítjuk kicsit.
        </p>
        <p>Element</p>
        <p>Ha bármilyen módon kiválasztasz egy HTML elemet az oldalon, egy Element típusú JavaScript objektumot fogsz
          visszakapni. Például igaz ez a querySelector használata esetén is.
        </p>
        <p>Element bővítése
        </p>
        <p>Az objektumoknál már tanultuk, hogy lehet bővíteni őket. De van egy bizonyos prototype-juk, azaz tervrajzuk
          vagy prototípusuk is. Minden új elem ez alapján a prototípus alapján készül. Így ha szeretnéd az összes HTML
          elemet felruházni egy új képességgel, akkor ezt a prototype-ban kell létrehoznod.</p>
        <p>Például lehet bővíteni az Element-et valamilyen metódussal:
        </p>
        <a href="img/dom.JPG" target="_blank"><img src="img/dom.JPG" class="img-fluid" alt="dom.JPG"></a>
        <p>Ez azért nem kicsit durva, nézzük át mégegyszer:</p>
        <ul>
          <li>Először megkeresem az inputot és elmentem az input nevű változóba.</li>
          <li>Bővítem az Element prototípusát egy új metódussal, a neve set Disabled lesz.</li>
          <li>Amikor meghívják, a this az az element lesz, ami után írják a metódus nevét.
            Beállítom az attribútumot és hozzáadok egy osztályt is az osztálylistához.
            Végül meghívom az adott elemre.
          </li>
        </ul>
        <p><strong>A HTML attributomok lekérdezése és módosítása</strong></p>
        <p>Attributes - a tulajdonságok</p>
        <p>Ahogy már megmutattam, a HTML elemek tulajdonságait attribútumoknak is hívjuk. Most ezeket fogjuk JavaScript
          segítségével módosítani.
        </p>
        <p>getAttribute - tulajdonságok lekérése</p>
        <p>Ez a metódus, a getAttribute függvény visszaadja egy adott HTML elem egy bizonyos attribútumának az értékét.
          Hogy mire vagy kíváncsi, azt neked kell megadnod.
        </p>
        <p>Emlékszel amikor a string változókat kellett vágni? Ott is megadtuk, hogy honnan kezdje a vágást és meddig
          vágjon? Tehát paraméterekkel láttuk el a metódust.</p>
        <p>Itt ugyanerről van szó, meg kell mondanunk a getAttribute függvénynek, hogy mire is vagyunk kíváncsiak, a
          sok tulajdonság közül konkrétan melyik is érdekel minket.</p>
        <a href="img/dom2.JPG" target="_blank"><img src="img/dom2.JPG" class="img-fluid" alt="dom2.JPG"></a>
        <p>Ez egy stringet fog visszaadni. Ha a H1 elem így néz ki:</p>
        <a href="img/dom3.JPG" target="_blank"><img src="img/dom3.JPG" class="img-fluid" alt="dom3.JPG"></a>
        <p>setAttribute - tulajdonságok módosítása</p>
        <p>Hasonlít a barátjához, de ezzel a HTML elem tulajdonságait nem lekérni, hanem módosítani tudod.</p>
        <p>Ebből fakad, hogy nem elég neki egy paraméter, meg kell adni az új értéket is a tulajdonság neve után. A
          példában egy HTML elem több tulajdonságát is módosítom:</p>
        <a href="img/dom4.JPG" target="_blank"><img src="img/dom4.JPG" class="img-fluid" alt="dom4.JPG"></a>
        <p><strong>Több elem módosítása ciklus segítségével</strong></p>
        <p>Gyakran kell majd egyszerre több HTML elem tulajdonságait is módosítanod. Ehhez kombináljuk a lekérdezést és
          a megismert ciklusokat egymással.
        </p>
        <p>Tehát végig kell menned az összes elemen, és egyesével módosítani a tulajdonságaikat.</p>
        <p>For - a legjobb választás</p>
        <p>Láttuk, hogy a querySelectorAll metódus visszaadja az összes elemet egy tömbben. Igen ám, de nem minden
          tömb, ami annak látszik.</p>
        <p><strong>NodeList:</strong> Ugyanis amit visszaad, az okosabb, mint egy tömb. Ezért vigyázni kell, ha végig
          akarsz menni az
          elemein, mert könnyen találkozhatsz olyannal, amelyikre nem működnek az ismert trükkök, mondjuk a
          setAttribute.</p>
        <p>De a length tulajdonság a segítségünkre siet:</p>
        <a href="img/dom5.JPG" target="_blank"><img src="img/dom5.JPG" class="img-fluid" alt="dom5.JPG"></a>
        <p>Semmi különös nem történt, csupán egy for ciklussal bejártam a NodeList elemeit, amelyek ebben a konkrét
          példában p elemek. A ciklusban pedig a háttérszínét mindegyiknek beállítottam pirosra.</p>
        <p>for...in - ha ragaszkodsz hozzá?!</p>
        <p>Ha mégis ragaszkodsz a jó öreg for...in ciklushoz, azzal is dolgozhatsz, de ebben az esetben precízen
          ellenőrizd le, hogy helyes HTML elemet kaptál-e!</p>
        <p>Ebben segítek neked a példában:</p>
        <a href="img/dom6.JPG" target="_blank"><img src="img/dom6.JPG" class="img-fluid" alt="dom6.JPG"></a>
        <p>Leellenőriztem, hogy van-e olyan tulajdonsága a myNodelist k kulcsú elemének, hogy style. Ha van, akkor
          beállítom a háttérszínt, ha nincs akkor nem hivatkozok rá mert hibát kapnék.</p>
        <p><strong>Több elem módosítása külön függvénnyel</strong></p>
        <p>Módosítás függvénnyel - a helyzet fokozódik</p>
        <p>Lépések:</p>
        <ul>
          <li>Készíts egy függvényt.</li>
          <li>Add át neki a szelektort, a tulajdonság nevét és értékét.</li>
          <li>A függvényben végigjárod az elemeket, és módosítod a tulajdonságot.</li>
          <li>Végül valamit vissza is adsz a kíváncsiak kedvéért.</li>
        </ul>
        <a href="img/dom7.JPG" target="_blank"><img src="img/dom7.JPG" class="img-fluid" alt="dom7.JPG"></a>
        <p><strong>Egy elem gyerekei</strong></p>
        <p>Children - az elem gyerekei</p>
        <p>A HTML elemek között van egy képletes szülő-gyerek kapcsolat. A beágyazott elemeket, amelyek egy másik
          elemben vannak, annak gyerekeinek is szokás nevezni. A következő metódusok is innen kapták a nevüket.</p>
        <p>childElementCount</p>
        <p>Az Element.childElementCount tulajdonság megmondja, hány gyereke van a HTML elemednek. Ez akkor lehet
          hasznos, ha keresel benne valamit. Ha először lekéred, hogy egyáltalán vannak-e gyerekei, nem fogsz
          feleslegesen dolgozni.</p>
        <a href="img/dom8.JPG" target="_blank"><img src="img/dom8.JPG" class="img-fluid" alt="dom8.JPG"></a>
        <p>childNodes vs. children</p>
        <p>Most megkeressük a gyerekeket.</p>
        <a href="img/dom9.JPG" target="_blank"><img src="img/dom9.JPG" class="img-fluid" alt="dom9.JPG"></a>
        <p><strong>Új elem létrehozása és hozzáadása gyerekként</strong></p>
        <p>Children - gyerek management</p>
        <p>Azt már tudod, hogyan kell lekérni egy Element gyerekeit, most azt is megmutatom, hogyan tudsz hozzáadni
          újat, vagy meglévőt eltávolítani.</p>
        <p>document.createElement()</p>
        <p>Mielőtt hozzá akarsz adni egy elemet egy másikhoz, nyilván létre kellene hozni.</p>
        <p>Ezt szolgálja a createElement metódus. Használata nagyon egyszerű. Megadod, hogy milyen elemet szeretnél
          létrehozni és elmented egy változóba:
        </p>
        <a href="img/dom10.JPG" target="_blank"><img src="img/dom10.JPG" class="img-fluid" alt="dom10.JPG"></a>
        <p>Element.appendChild()</p>
        <p>A neve alapján tehát hozzáfűz egy új elemet a meglévőhöz. Egészen pontosan nem is hozzá, hanem bele fűzi,
          mivel ezzel a metódussal abban az Element-ben hoz létre egy új gyerek Element-et, amelyre a metódust meghívod.
        </p>
        <p>Az új elem az utolsó lesz a szülő Element gyerekei között.</p>
        <p>Lépésről lépésre:</p>
        <ul>
          <li>Kell egy Element, amibe bele akarod tenni az újat. querySelector</li>
          <li>Létre kell hozni egy új elemet. createElement</li>
          <li>Ha szükséges, be lehet állítani az új Element tuajdonságait. setAttribute</li>
          <li>Végül az új elemet hozzáadod a kiválaszott Element -hez. appendChild</li>
        </ul>
        <p>Bővebben a példában:</p>
        <a href="img/dom11.JPG" target="_blank"><img src="img/dom11.JPG" class="img-fluid" alt="dom11.JPG"></a>
        <p>Element.removeChild(node)</p>
        <p>Egy kis szintaxis: node.removeChild(node) Nagyon hasonlít a testvérére az appendChild-ra, csak nem kell
          elemet létrehozni.
        </p>
        <p>Lépésről lépésre:</p>
        <ul>
          <li>Kell egy Element, amiből az egyik child -ot el akarjuk távolítani. querySelector</li>
          <li>Kell az az elem, amit el akarunk távolítani. querySelector</li>
          <li>Végül az eltávolítás. Fontos, hogy csak child elemet lehet. removeChild</li>
        </ul>
        <p>Bővebben a példában:</p>
        <a href="img/dom12.JPG" target="_blank"><img src="img/dom12.JPG" class="img-fluid" alt="dom12.JPG"></a>
        <p>Egy elem szülője</p>
        <p>Parent
        </p>
        <p>Angolul szülőt jelent, és az is. Ha egy elemnek lehetnek gyerekei, és meg lehet kérdezni, hogy hány gyereke
          van, és akár keresni is lehet közöttük, ugyanígy ha a gyermek elem felől nézzük a dolgot, annak is működnie
          kell. Jöjjön a kik a szüleid kérdés. Illetve pontosítok: ki a szülőd, mivel minden elemnek csak egyetlen
          közvetlen szülője lehet.
        </p>
        <p>parentNode vs parentElement</p>
        <p><strong>parentNode:</strong> az adott elem szülő node-ját adja vissza , mely lehet Element vagy gyökérelem
          esetén a document.</p>
        <p><strong>parentElement:</strong> az adott elem szülő elemét adja vissza, mely mindig egy Element, vagy
          gyökérelem esetén null.</p>
        <p>Fontos különbség van a node és az element között. A Node egy csomópont a dokumentumban, lehet egy
          egyszerű textNode is, ami nem valódi HTML Element. Mert minden Element node, de nem minden node element :)
        </p>
        <a href="img/dom13.JPG" target="_blank"><img src="img/dom13.JPG" class="img-fluid" alt="dom13.JPG"></a>
        <p>Munka a szülőkkel</p>
        <p>
          A példában elrejtem a span szülőjét a kíváncsi tekintetek elől:</p>
        <a href="img/dom14.JPG" target="_blank"><img src="img/dom14.JPG" class="img-fluid" alt="dom14.JPG"></a>
        <p><strong>Eseménykezelők hozzáadasa HTML elemekhez</strong></p>
        <p>A JavaScriptben lehetőség van eseményeket figyelni, és a hatásukra valamilyen kódot futtatni. Ilyen esemény
          például amikor betöltődik az oldal, vagy a felhasználó rákattint egy elemre.</p>
        <p>= vs.addEventListener</p>
        <p>Ha azt szeretnéd, hogy történjen valami, ha mondjuk egy gombra kattintanak, azt háromféleképpen is meg tudod
          adni.
        </p>
        <ul>
          <li>Element attribútummal: "<"elementonclick="myScript"">"</li>
          <li>JavaScriptből hasonlóan: object.onclick=function()myScript;</li>
          <li>addEventListenerrel: object.addEventListener("click",myScript);</li>
        </ul>
        <p>Az első kettőnél egy eseményre csak egy működést adhatsz meg, míg az addEventListener használatával többet
          is.</p>
        <p><strong>Fontos:</strong> addEventListener esetén nem kell az on szócska az esemény neve elé.</p>
        <p><strong>window események</strong></p>
        <p>A közös bennük, hogy nem felhasználói beavatkozásra történnek meg, hanem a böngésző működése váltja ki őket.
          Nem csak a window-ra lehet őket megadni, a legtöbb elem esetén használhatóak.</p>
        <p>A fontosabbak:</p>
        <ul>
          <li><strong>onload</strong> az objektum betöltődött</li>
          <li><strong>onresize</strong> az objektumot átméretezték</li>
          <li><strong>onscroll</strong> scrolloztak az objektumon</li>
        </ul>
        <p>Például figyelhetjük ha scrolloztak, és egy bizonyos távolsagra az oldal tetejétől kisebbre vehetjük a
          fejlécet, vagy elrejthetünk bizonyos elemeket:</p>
        <a href="img/dom15.JPG" target="_blank"><img src="img/dom15.JPG" class="img-fluid" alt="dom15.JPG"></a>
        <p><strong>Az egér és az űrlapelemek eseményei</strong></p>
        <p>A leggyakrabban figyelt események az egér események. Itt bejönnek a képbe a mobil eszközök is, mert ott már
          nincs egér, hanem legtöbbször ujjal kezelik őket. Ezeknél a kattintás a tap-et, azaz a tapintást jelenti.
        </p>
        <p>A legfontosabbak:</p>
        <ul>
          <li>
            <strongon>onclick</strongon> kattintás vagy tappintás, ha mobileszközről van szó
          </li>
          <li>
            <strongon>onmouseover</strongon> az elem fölé viszik az egérmutatót (mobilon értelmetlen)
          </li>
          <li>
            <strongon>onmouseout</strongon> az elemről elhúzzák az egérmutatót (mobilon értelmetlen)
          </li>
        </ul>
        <p>Mindegyiket valamilyen konkrét HTML elemre, azaz Element típusú objektumra lehet beállítani, a fent
          részletezett három mód valamelyikével:</p>
        <a href="img/dom16.JPG" target="_blank"><img src="img/dom16.JPG" class="img-fluid" alt="dom16.JPG"></a>
        <p><strong>onchange és onsubmit - form elemek</strong></p>
        <p>Fontos értesülnöd róla, ha valaki piszkálja a formot.
        </p>
        <ul>
          <li><strong>onchange</strong> input elemek értékének változását figyelheted.</li>
          <li><strong>onsubmit</strong> a form (űrlap) elküldése előtt fut le, ezt figyelheted vele. Ha az eseménykezelő
            függvény visszatérési értéke</li>
          <li>false, akkor az űrlap nem kerül elküldésre.</li>
        </ul>
        <a href="img/dom17.JPG" target="_blank"><img src="img/dom17.JPG" class="img-fluid" alt="dom17.JPG"></a>
        <h2 id="switch">A switch kapcsoló</h2>
        <p>Ahogy a neve is mutatja, a switch egy kapcsoló. Több állása is lehet, egy változót vagy kifejezést vizsgál,
          és annak az értéke alapján ugrik a megfelelő utasításhoz.</p>
        <p>Használata:</p>
        <p>Egy paramétere van, egy olyan változó vagy kifejezés, ami értéket ad vissza. Azután meg kell adni, hogy
          milyen érték hatására milyen utasítás fusson le.</p>
        <p>Kulcsszavak:</p>
        <ul>
          <li>switch(value) - a value az az érték, amit figyel a switch.</li>
          <li>case value: kifejezés break; - ha a value megegyezik a vizsgált értékkel, lefut a kifejezés, utána break
            utasítást teszünk, hogy a többi ne fusson le.</li>
          <li>default: kifejez - ha egyik case sem volt igaz, akkor ez fog lefutni.</li>
        </ul>
        <p>Előnye, hogy gyorsabb, mint az else...if, viszont csak konkrét értékeket lehet vele vizsgálni, azaz például
          kisebb-nagyobb logikai kifejezést nem tud értelmezni.
        </p>
        <p>Megkeresem a hét napjának nevét a száma alapján:
        </p>
        <a href="img/switch.JPG" target="_blank"><img src="img/switch.JPG" class="img-fluid" alt="switch.JPG"></a>
        <h2 id="domwhileesfor">DOM manipuláció while és for ciklussal</h2>
        <p>Most összetett struktúrákat, listákat, táblázatokat fogunk generálni js-el. Izgalmas lesz.
        </p>
        <p><strong>While ciklussal</strong></p>
        <p>Bemelegítésnek készítek egy p elemekből álló listát while ciklussal:
        </p>
        <a href="img/domwhile.JPG" target="_blank"><img src="img/domwhile.JPG" class="img-fluid" alt="domwhile.JPG"></a>
        <p>Mit tettem?
        </p>
        <ul>
          <li>Létrehoztam a numbers tömböt.</li>
          <li>Beállítottam az i változót, ez lett az index.</li>
          <li>Megkerestem az első div-et az oldalon.</li>
          <li>Addig futtattam a while ciklust, amíg kisebb az i, mint a tömb hossza.</li>
          <li>A ciklusban létrehoztam egy p elemet és beállítottam a tartalmát a numbers tömb aktuális elemére.</li>
          <li>Hozzáadtam a p elemet a container-hez, ami egy div.</li>
          <li>Végül növeltem az i változót eggyel.</li>
        </ul>
        <p>Táblázat rajzolása objektumtömbből
        </p>
        <p>Amikor egy szerverről megkapod mondjuk a felhasználókat, az a legtöbbször egy tömb lesz, ami az egyes
          felhasználókat objektumként tartalmazza. Erre szokták mondani, hogy objektumtömb, vagy objektumok tömbje.
        </p>
        <p>Legyen hát egy objektumtömböd:
        </p>
        <a href="img/domwhile2.JPG" target="_blank"><img src="img/domwhile2.JPG" class="img-fluid"
            alt="domwhile2.JPG"></a>
        <p>Minden felhasználó objektuma azonosan épül fel, de az adataik természetesen különbözőek.
        </p>
        <p><strong>DOM manipulálása for ciklussal</strong></p>
        <p>Rajzolj táblázatot:
        </p>
        <a href="img/domfor.JPG" target="_blank"><img src="img/domfor.JPG" class="img-fluid" alt="domfor.JPG"></a>
        <p>A helyes táblázathoz két egymásba ágyazott ciklus kell. Az egyikben létrehozod a sorokat, a másikban a
          cellákat a sorokon belül. Amikor elkészíted a fenti példát a saját gépeden, használd a Google Chrome beépített
          debug eszközét ahogy tanultuk. Állítsd meg minden sorban a ciklusokat és nézd végig a változók pillanatnyi
          értékét.
        </p>





      </div>
      <div class="col-12 col-md-3 col-lg-2 p-0">
        <div id="menusor">
          <ul class="almenu">
            <li><a href="#dom">A DOM</a></li>
            <li><a href="#switch">A switch kapcsoló</a></li>
            <li><a href="#domwhileesfor">DOM manipuláció while és for ciklussal</a></li>
            <li><a href="#oldalteteje">Vissza az oldal tetejére</a></li>
          </ul>
        </div>
      </div>
    </div>
    </div>
    </div>
    </div>
  </main>
  <script src="./js az aloldalaknak/javaScript.js"></script>
</body>

</html>